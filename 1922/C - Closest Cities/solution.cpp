#include<bits/stdc++.h>using namespace std;typedef long long ll;void f(ll n,vector<ll>&a){    for(ll i=0;i<n;i++)cin>>a[i];}// ll check(ll a,ll b,vector<ll>&closest,vector<ll>&vec){//     ll ans=0; //     while (a!=b)//     {//         if((closest[a]>a && closest[a]>b) || (closest[a]<a && closest[a]<b)){//            if(a>b)ans+=vec[a]-vec[a-1],a-=1;//             else ans+=vec[a+1]-vec[a],a+=1;//         }//         else ans++,a=closest[a];//     }//     return ans;// }// void solve(){//     ll n,m;//     cin>>n;//     vector<ll>vec(n),closest(n);    // closest[0]=1,closest[n-1]=n-2;    // f(n,vec);    // for (ll i = 1; i < n-1; i++)    // {    //     if(vec[i+1]-vec[i]>vec[i]-vec[i-1])closest[i]=i-1;    //     else closest[i]=i+1;    // }    // cin>>m;    // for (ll i = 0; i < m; i++)    // {    //     ll a,b;    //     cin>>a>>b;    //    cout<<check(a-1,b-1,closest,vec)<<'\n';    // }    // cout<<'\n';   // } void solve(){    ll n,m;    cin>>n;    vector<ll>vec(n),left(n,0),right(n,0);    f(n,vec);    cin>>m;    // we can solve it like this , if we want to go from 2 to 5 then we can count cost to reach 5 from 1 and similarly for 2 and then subtract it to get the cost of reaching 5 from 2 . similarily we can do for right to left side movements.    for (ll i = 1; i < n; i++)    {        if(i==1)left[i]=1;        else{            ll prev=vec[i-1];            if(vec[i]-prev<prev-vec[i-2])left[i]+=left[i-1]+1;            else left[i]+=left[i-1]+vec[i]-prev;        }    }        for (ll i = n-2; i>=0; i--)    {        if(i==n-2)right[i]=1;        else{            ll prev=vec[i+1];            if(prev-vec[i]<vec[i+2]-prev)right[i]+=right[i+1]+1;            else right[i]+=right[i+1]+prev-vec[i];        }    }    for (ll i = 0; i < m; i++)    {        ll a,b;        cin>>a>>b;        if(a<b)cout<<left[b-1]-left[a-1];        else cout<<right[b-1]-right[a-1];        cout<<'\n';    }    }int main(){ll t;cin>>t;while (t--){    solve();}     return 0;}