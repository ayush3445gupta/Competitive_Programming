#include<bits/stdc++.h>using namespace std;typedef long long ll;const ll N = 200005;void f(ll n,vector<ll>&a){    for(ll i=0;i<n;i++)cin>>a[i];}vector<int>smallest_prime_factors(N+1);void sieve(){   iota(begin(smallest_prime_factors),end(smallest_prime_factors),0);   for (ll i = 2; i*i<=N; i++)   {    if(smallest_prime_factors[i]==i){        // it is prime number , mark its every factors as this value as it is smallest prime factors for those numbers        for (ll j = i*i; j <=N; j+=i)        {            if(smallest_prime_factors[j]==j)smallest_prime_factors[j]=i;        }    }   }}vector<ll>get_factors(ll x){    vector<ll>factors;    while (x>1)    {        ll p=smallest_prime_factors[x];        factors.push_back(p);        while (x%p==0)x/=p;    }    return factors;}void solve(){    ll n;    cin>>n;    vector<ll>a(n),b(n);    f(n,a);    f(n,b);         // check if gcd>1 exists already    unordered_set<ll>used;    for (ll i = 0; i < n; i++)    {        auto facts = get_factors(a[i]);        for(ll p:facts)        {            if(used.count(p)){            cout<<0<<'\n';            return;            }            used.insert(p);        }    }     // check if gcd>1 after +1 operations// Step 2: check if gcd > 1 after increasing just one elementunordered_set<int>base_primes;for (ll i = 0; i < n; i++) {    for (ll p:get_factors(a[i]))        base_primes.insert(p);} for (ll i=0;i<n;i++) {    auto facts=get_factors(a[i]+1);    for (ll p:facts) {        if (base_primes.count(p)) {            cout << 1 << "\n";            return;        }    }}     cout<<2<<'\n';} int main(){ll t;cin>>t;sieve();while (t--){    solve();}     return 0;}